#!/bin/bash
# vim: set ft=sh sw=2:

export GOARCH=$(go env GOARCH 2>/dev/null || echo "amd64")

_ROOT="$(dirname "${BASH_SOURCE}")/.."

ARCH=$([ "$(uname -m)" = "x86_64" ] && echo amd64 || echo arm64)
export PATH="${HOME}/.local/bin:${HOME}/.cargo/bin:${PATH}"

log::f () {
 printf "INFO: %s $*\n" "$(date)"
}

log::e () {
  printf "ERROR: %s  $*\n" "$(date)"
}

gh::download() {
  local repo version artifact output
  repo=$1
  version=$2
  artifact=$3
  output=$4

  echo "Downloading release ${version} of ${artifact} from ${repo}"

  curl -sfLo "${output}" "https://github.com/${repo}/releases/download/${version}/${artifact}"
}

uv::ensure_installed() {
  if command -v uv >/dev/null 2>&1; then
    log::f "uv already installed: $(uv --version)"
    return 0
  fi

  log::f "Installing uv"
  curl -LsSf https://astral.sh/uv/install.sh | sh
  export PATH="${HOME}/.local/bin:${HOME}/.cargo/bin:${PATH}"

  if ! command -v uv >/dev/null 2>&1; then
    log::e "uv installation completed but uv is not on PATH"
    return 1
  fi
}

uv::tool_install() {
  local tool=$1
  uv::ensure_installed
  uv tool install --force --upgrade "${tool}"
}

tools::install_starship() {
  if command -v starship >/dev/null 2>&1; then
    log::f "starship already installed: $(starship --version)"
    return 0
  fi

  log::f "Installing starship to ${HOME}/.local/bin"
  mkdir -p "${HOME}/.local/bin"
  curl -fsSL https://starship.rs/install.sh | sh -s -- -y -b "${HOME}/.local/bin"
}

nvm::ensure_installed() {
  local nvm_version
  nvm_version="${NVM_VERSION:-v0.40.3}"
  export NVM_DIR="${NVM_DIR:-${HOME}/.nvm}"

  if [ -s "${NVM_DIR}/nvm.sh" ]; then
    return 0
  fi

  log::f "Installing nvm ${nvm_version}"
  git clone https://github.com/nvm-sh/nvm.git "${NVM_DIR}"
  (
    cd "${NVM_DIR}"
    git checkout "${nvm_version}"
  )
}

nvm::load() {
  export NVM_DIR="${NVM_DIR:-${HOME}/.nvm}"
  if [ ! -s "${NVM_DIR}/nvm.sh" ]; then
    return 1
  fi

  # shellcheck source=/dev/null
  . "${NVM_DIR}/nvm.sh"
}

nvm::link_default_node_binaries() {
  local default_node_bin default_node_root
  default_node_bin="$(nvm which default 2>/dev/null || true)"
  if [ -z "${default_node_bin}" ] || [ "${default_node_bin}" = "N/A" ]; then
    return 0
  fi

  default_node_root="${default_node_bin%/bin/node}"
  mkdir -p "${HOME}/.local/bin"
  ln -sf "${default_node_root}/bin/node" "${HOME}/.local/bin/node"
  ln -sf "${default_node_root}/bin/npm" "${HOME}/.local/bin/npm"
  ln -sf "${default_node_root}/bin/npx" "${HOME}/.local/bin/npx"
}

nvm::install_node_default() {
  local node_version
  node_version="${NVM_NODE_VERSION:-lts/*}"

  nvm::ensure_installed
  nvm::load
  nvm install "${node_version}"
  nvm alias default "${node_version}"
  nvm use default >/dev/null
  nvm::link_default_node_binaries
  log::f "Using node $(node --version) and npm $(npm --version)"
}

docker::ensure_compose() {
  if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
    return 0
  fi

  log::f "Ensuring docker compose v2 is installed"
  sudo apt update
  sudo apt install -y --no-install-recommends docker-compose-v2
}

os::ubuntu::ensure_bootstrap_tools() {
  local bootstrap_pkgs=()

  command -v curl >/dev/null 2>&1 || bootstrap_pkgs+=(curl)
  command -v gpg >/dev/null 2>&1 || bootstrap_pkgs+=(gnupg)

  if [ "${#bootstrap_pkgs[@]}" -gt 0 ]; then
    log::f "Installing bootstrap tools: ${bootstrap_pkgs[*]}"
    sudo apt update
    sudo apt install -y --no-install-recommends "${bootstrap_pkgs[@]}"
  fi
}

apt::install_if_available() {
  local packages=("$@")
  local available=()
  local skipped=()
  local pkg candidate policy_output

  for pkg in "${packages[@]}"; do
    policy_output="$(apt-cache policy "${pkg}" 2>/dev/null || true)"
    candidate="$(awk '/Candidate:/ {print $2; exit}' <<<"${policy_output}")"
    if [ -n "${candidate}" ] && [ "${candidate}" != "(none)" ]; then
      available+=("${pkg}")
    else
      skipped+=("${pkg}")
    fi
  done

  if [ "${#available[@]}" -gt 0 ]; then
    sudo apt install -y --no-install-recommends "${available[@]}"
  fi

  if [ "${#skipped[@]}" -gt 0 ]; then
    log::f "Skipping unavailable apt packages: ${skipped[*]}"
  fi
}

desktop::status_one() {
  local label cmd
  label="$1"
  cmd="$2"

  if command -v "${cmd}" >/dev/null 2>&1; then
    log::f "${label}: installed (${cmd})"
  else
    log::f "${label}: not installed"
  fi
}

desktop::ensure_universe_repo() {
  local source_files source_components
  if [ "${DISTRO:-}" != "Ubuntu" ]; then
    return 0
  fi

  if ! command -v add-apt-repository >/dev/null 2>&1; then
    return 0
  fi

  source_files="$(grep -RhsE '^[[:space:]]*deb .*ubuntu.* universe([[:space:]]|$)' /etc/apt/sources.list /etc/apt/sources.list.d/*.list 2>/dev/null || true)"
  source_components="$(grep -RhsE '^[[:space:]]*Components:.*(^|[[:space:]])universe([[:space:]]|$)' /etc/apt/sources.list.d/*.sources 2>/dev/null || true)"
  if [ -n "${source_files}" ] || [ -n "${source_components}" ]; then
    return 0
  fi

  log::f "Enabling Ubuntu universe repository for desktop packages"
  sudo add-apt-repository -y universe
  sudo apt update
}

desktop::install_clipboard_and_caffeine() {
  # Install clipboard utilities plus GNOME clipboard/caffeine extensions.
  desktop::ensure_universe_repo
  apt::install_if_available \
    wl-clipboard \
    xsel \
    gnome-shell-extension-clipboard-indicator \
    gnome-shell-extension-caffeine \
    caffeine

  # If distro packages are unavailable, attempt installation from extensions.gnome.org
  # via GNOME Shell DBus (requires an active GNOME user session).
  desktop::install_gnome_extension_remote "clipboard-indicator@tudmotu.com"
  desktop::install_gnome_extension_remote "caffeine@patapon.info"
}

desktop::install_gnome_extension_remote() {
  local extension_id desktop_hint install_result
  extension_id="$1"
  desktop_hint="${XDG_CURRENT_DESKTOP:-}${DESKTOP_SESSION:-}"

  if command -v gnome-extensions >/dev/null 2>&1 && gnome-extensions list 2>/dev/null | grep -Fxq "${extension_id}"; then
    return 0
  fi

  if ! grep -qi "gnome" <<<"${desktop_hint}"; then
    return 0
  fi

  if ! command -v gdbus >/dev/null 2>&1; then
    log::f "Cannot auto-install GNOME extension (${extension_id}): gdbus not available"
    return 0
  fi

  install_result="$(gdbus call --session \
    --dest org.gnome.Shell.Extensions \
    --object-path /org/gnome/Shell/Extensions \
    --method org.gnome.Shell.Extensions.InstallRemoteExtension \
    "${extension_id}" 2>/dev/null || true)"

  if command -v gnome-extensions >/dev/null 2>&1 && gnome-extensions list 2>/dev/null | grep -Fxq "${extension_id}"; then
    log::f "Installed GNOME extension: ${extension_id}"
  elif [ -n "${install_result}" ]; then
    log::f "GNOME extension install requested for ${extension_id}; relog may be required"
  else
    log::f "Could not auto-install GNOME extension: ${extension_id}"
  fi
}

desktop::ensure_gnome_extension_enabled() {
  local extension_id
  extension_id="$1"

  if ! command -v gnome-extensions >/dev/null 2>&1; then
    return 0
  fi

  if ! gnome-extensions list 2>/dev/null | grep -Fxq "${extension_id}"; then
    return 0
  fi

  if gnome-extensions info "${extension_id}" 2>/dev/null | grep -q '^State: ENABLED$'; then
    return 0
  fi

  if gnome-extensions enable "${extension_id}" >/dev/null 2>&1; then
    log::f "Enabled GNOME extension: ${extension_id}"
  else
    log::f "Could not enable GNOME extension automatically: ${extension_id}"
  fi
}

desktop::ensure_desktop_extensions_enabled() {
  desktop::ensure_gnome_extension_enabled "clipboard-indicator@tudmotu.com"
  desktop::ensure_gnome_extension_enabled "caffeine@patapon.info"
}

desktop::apply_gnome_extension_preferences() {
  local clipboard_dconf caffeine_dconf
  clipboard_dconf="${_ROOT}/config/gnome/clipboard-indicator.dconf"
  caffeine_dconf="${_ROOT}/config/gnome/caffeine.dconf"

  if ! command -v dconf >/dev/null 2>&1; then
    log::f "Skipping GNOME extension preference apply: dconf not found"
    return 0
  fi

  if [ -s "${clipboard_dconf}" ]; then
    if dconf load /org/gnome/shell/extensions/clipboard-indicator/ < "${clipboard_dconf}" 2>/dev/null; then
      log::f "Applied clipboard indicator preferences from ${clipboard_dconf}"
    else
      log::f "Could not apply clipboard indicator preferences (likely no active GNOME session)"
    fi
  fi

  if [ -s "${caffeine_dconf}" ]; then
    if dconf load /org/gnome/shell/extensions/caffeine/ < "${caffeine_dconf}" 2>/dev/null; then
      log::f "Applied caffeine extension preferences from ${caffeine_dconf}"
    else
      log::f "Could not apply caffeine extension preferences (likely no active GNOME session)"
    fi
  fi
}

desktop::status_clipboard_and_caffeine() {
  local enabled_extensions
  desktop::status_one "xclip" "xclip"
  desktop::status_one "xsel" "xsel"
  desktop::status_one "wl-clipboard" "wl-paste"
  desktop::status_one "Caffeine" "caffeine"
  if command -v gnome-extensions >/dev/null 2>&1; then
    enabled_extensions="$(gsettings get org.gnome.shell enabled-extensions 2>/dev/null || true)"

    if gnome-extensions list 2>/dev/null | grep -Fxq "clipboard-indicator@tudmotu.com"; then
      if grep -Fq "clipboard-indicator@tudmotu.com" <<<"${enabled_extensions}"; then
        log::f "Clipboard Indicator extension: enabled"
      else
        log::f "Clipboard Indicator extension: installed but disabled"
      fi
    else
      log::f "Clipboard Indicator extension: not installed"
    fi

    if gnome-extensions list 2>/dev/null | grep -Fxq "caffeine@patapon.info"; then
      if grep -Fq "caffeine@patapon.info" <<<"${enabled_extensions}"; then
        log::f "Caffeine extension: enabled"
      else
        log::f "Caffeine extension: installed but disabled"
      fi
    else
      log::f "Caffeine extension: not installed"
    fi
  fi
}

os::debian_codename() {
  if command -v lsb_release >/dev/null 2>&1; then
    lsb_release -cs
    return 0
  fi

  if [ -r /etc/os-release ]; then
    # shellcheck disable=SC1091
    . /etc/os-release
    if [ -n "${VERSION_CODENAME:-}" ]; then
      echo "${VERSION_CODENAME}"
      return 0
    fi
  fi

  return 1
}

os::ubuntu::ensure_cloudflared_repo() {
  local keyring listfile desired_line
  keyring="/usr/share/keyrings/cloudflare-main.gpg"
  listfile="/etc/apt/sources.list.d/cloudflared.list"
  desired_line="deb [arch=amd64 signed-by=${keyring}] https://pkg.cloudflare.com/cloudflared any main"

  curl -fsSL https://pkg.cloudflare.com/cloudflare-main.gpg | sudo tee "${keyring}" >/dev/null

  if [ ! -f "${listfile}" ] || ! grep -Fxq "${desired_line}" "${listfile}" 2>/dev/null; then
    echo "${desired_line}" | sudo tee "${listfile}" >/dev/null
  fi
}

os::ubuntu::ensure_tailscale_repo() {
  local codename distro_path key_url list_url keyring listfile
  codename="$(os::debian_codename || true)"
  if [ -z "${codename}" ]; then
    log::f "Skipping tailscale repo setup: unable to determine distro codename"
    return 0
  fi

  keyring="/usr/share/keyrings/tailscale-archive-keyring.gpg"
  listfile="/etc/apt/sources.list.d/tailscale.list"

  case "${DISTRO}" in
    Ubuntu) distro_path="ubuntu" ;;
    debian) distro_path="debian" ;;
    *) distro_path="ubuntu" ;;
  esac

  key_url="https://pkgs.tailscale.com/stable/${distro_path}/${codename}.noarmor.gpg"
  list_url="https://pkgs.tailscale.com/stable/${distro_path}/${codename}.tailscale-keyring.list"

  if [ ! -f "${keyring}" ]; then
    curl -fsSL "${key_url}" | sudo tee "${keyring}" >/dev/null
  fi

  if [ ! -f "${listfile}" ] || ! grep -q 'pkgs.tailscale.com' "${listfile}" 2>/dev/null; then
    curl -fsSL "${list_url}" | sudo tee "${listfile}" >/dev/null
  fi
}

os::ubuntu::ensure_opentofu_repo() {
  local keyring_main keyring_repo listfile
  keyring_main="/etc/apt/keyrings/opentofu.gpg"
  keyring_repo="/etc/apt/keyrings/opentofu-repo.gpg"
  listfile="/etc/apt/sources.list.d/opentofu.list"

  sudo install -m 0755 -d /etc/apt/keyrings

  if [ ! -f "${keyring_main}" ]; then
    curl -fsSL https://get.opentofu.org/opentofu.gpg | sudo tee "${keyring_main}" >/dev/null
    sudo chmod a+r "${keyring_main}"
  fi

  if [ ! -f "${keyring_repo}" ]; then
    curl -fsSL https://packages.opentofu.org/opentofu/tofu/gpgkey | \
      sudo gpg --no-tty --batch --dearmor -o "${keyring_repo}" >/dev/null
    sudo chmod a+r "${keyring_repo}"
  fi

  if [ ! -f "${listfile}" ] || ! grep -q 'packages.opentofu.org/opentofu/tofu' "${listfile}" 2>/dev/null; then
    cat <<EOF | sudo tee "${listfile}" >/dev/null
deb [signed-by=${keyring_main},${keyring_repo}] https://packages.opentofu.org/opentofu/tofu/any/ any main
deb-src [signed-by=${keyring_main},${keyring_repo}] https://packages.opentofu.org/opentofu/tofu/any/ any main
EOF
  fi
}

os::ubuntu::apt_repo_hygiene() {
  # Clean up stale Docker source entries that point to Ubuntu focal.
  # These trigger apt warnings on noble and can conflict with the canonical repo config.
  local stale_repo="/etc/apt/sources.list.d/archive_uri-https_download_docker_com_linux_ubuntu-noble.list"
  if [ -f "${stale_repo}" ] && grep -q 'download.docker.com/linux/ubuntu focal' "${stale_repo}"; then
    log::f "Removing stale docker apt source: ${stale_repo}"
    sudo rm -f "${stale_repo}"
  fi
}

os::get_distro() {
  local uname_lc
  # Determine OS platform
  uname_lc=$(uname | tr "[:upper:]" "[:lower:]")

  # If Linux, try to determine specific distribution
  if [ "${uname_lc}" == "linux" ]; then
    # If available, use LSB to identify distribution
    if [ -f /etc/lsb-release -o -d /etc/lsb-release.d ]; then
      export DISTRO=$(lsb_release -i | cut -d: -f2 | sed s/'^\t'//)
    # Otherwise, use release info file
    else
      export DISTRO=$(ls -d /etc/[A-Za-z]*[_-][rv]e[lr]* | grep -v "lsb" | cut -d'/' -f3 | cut -d'-' -f1 | cut -d'_' -f1)
    fi
  fi

  # For everything else (or if above failed), just use generic identifier
  [ "${DISTRO:-}" == "" ] && export DISTRO="${uname_lc}"

  log::f "Detected Linux distrubtion: ${DISTRO}"
}

os::ensure_zsh() {
  if command -v zsh >/dev/null 2>&1; then
    return 0
  fi

  if [[ "${DISTRO:-}" =~ ^(Ubuntu|debian)$ ]] && command -v apt-get >/dev/null 2>&1; then
    log::f "zsh not found; installing via apt"
    sudo apt update
    sudo apt install -y --no-install-recommends zsh
    return 0
  fi

  log::f "zsh not found and no supported installer for DISTRO=${DISTRO:-unknown}"
}

os::ensure_user_shell_zsh() {
  local desired_shell current_shell user_name
  desired_shell="$(command -v zsh || true)"
  user_name="${USER:-$(id -un)}"

  if [ -z "${desired_shell}" ]; then
    log::f "Skipping default shell update: zsh binary not found"
    return 0
  fi

  current_shell="$(getent passwd "${user_name}" | cut -d: -f7)"
  if [ "${current_shell}" = "${desired_shell}" ]; then
    return 0
  fi

  if ! command -v chsh >/dev/null 2>&1; then
    log::f "Skipping default shell update: chsh command unavailable"
    return 0
  fi

  if chsh -s "${desired_shell}" "${user_name}"; then
    log::f "Updated login shell for ${user_name} to ${desired_shell}"
    log::f "Open a new terminal session to use zsh as the default shell"
  else
    log::f "Unable to update login shell automatically; run: chsh -s ${desired_shell}"
  fi
}

fonts::install_nerd_font() {
  local font_name version fonts_dir font_dir tmpdir tarball zipball
  font_name="${NERD_FONT_NAME:-FiraCode}"
  version="${NERD_FONT_VERSION:-v3.4.0}"
  fonts_dir="${HOME}/.local/share/fonts"
  font_dir="${fonts_dir}/NerdFonts/${font_name}"
  tmpdir="$(mktemp -d)"
  tarball="${tmpdir}/${font_name}.tar.xz"
  zipball="${tmpdir}/${font_name}.zip"

  if [ -d "${font_dir}" ] && find "${font_dir}" -type f -name '*Nerd Font*.ttf' | grep -q .; then
    log::f "Nerd Font already installed at ${font_dir}"
    rm -rf "${tmpdir}"
    return 0
  fi

  mkdir -p "${font_dir}"

  if curl -fsSL "https://github.com/ryanoasis/nerd-fonts/releases/download/${version}/${font_name}.tar.xz" -o "${tarball}"; then
    tar -xJf "${tarball}" -C "${font_dir}"
  else
    log::f "tar.xz artifact unavailable; trying zip fallback"
    curl -fsSL "https://github.com/ryanoasis/nerd-fonts/releases/download/${version}/${font_name}.zip" -o "${zipball}"
    unzip -q "${zipball}" -d "${font_dir}"
  fi

  find "${font_dir}" -type f \( -name '*.md' -o -name 'LICENSE' -o -name '*.txt' \) -delete

  if command -v fc-cache >/dev/null 2>&1; then
    fc-cache -f "${fonts_dir}" || true
  fi

  rm -rf "${tmpdir}"
  log::f "Installed ${font_name} Nerd Font (${version}) to ${font_dir}"
}

terminal::configure_gnome_terminal_font() {
  local font_name font_spec profile_id profile_path
  font_name="${NERD_FONT_NAME:-FiraCode}"
  font_spec="${TERMINAL_FONT_SPEC:-${font_name} Nerd Font Mono 11}"

  if ! command -v gsettings >/dev/null 2>&1; then
    log::f "Skipping GNOME Terminal font config: gsettings not found"
    return 0
  fi

  if ! gsettings describe org.gnome.Terminal.ProfilesList default >/dev/null 2>&1; then
    log::f "Skipping GNOME Terminal font config: terminal schema unavailable"
    return 0
  fi

  profile_id="$(gsettings get org.gnome.Terminal.ProfilesList default 2>/dev/null | tr -d "'")"
  if [ -z "${profile_id}" ]; then
    log::f "Skipping GNOME Terminal font config: no default profile detected"
    return 0
  fi

  profile_path="/org/gnome/terminal/legacy/profiles:/:${profile_id}/"
  if ! gsettings writable "org.gnome.Terminal.Legacy.Profile:${profile_path}" font >/dev/null 2>&1; then
    log::f "Skipping GNOME Terminal font config: no writable settings session"
    return 0
  fi

  gsettings set "org.gnome.Terminal.Legacy.Profile:${profile_path}" use-system-font false || true
  gsettings set "org.gnome.Terminal.Legacy.Profile:${profile_path}" font "${font_spec}" || true
  log::f "Configured GNOME Terminal default profile font: ${font_spec}"
}

kube::binaries() {
  local kube_hooks
  kube_hooks="${_ROOT}/hooks/kubernetes"

  if [ ! -f "${kube_hooks}" ]; then
    log::e "kubernetes hook not found at ${kube_hooks}"
    return 1
  fi

  BIN_DIR="${HOME}/bin"
  mkdir -p "${BIN_DIR}"

  # Reuse the canonical installer implementation.
  # shellcheck source=hooks/kubernetes
  . "${kube_hooks}"
  kube::install_kubectl

  log::f "Installed kubectl to ${BIN_DIR}/kubectl"
  log::f "To install helm/k3d safely, source hooks/kubernetes and run kube::install_helm / kube::install_k3d"
}

os::ubuntu::install_packages() {
  os::ubuntu::install_packages_core
}

os::ubuntu::install_packages_core() {
  log::f "Installing core apt packages"

  os::ubuntu::ensure_bootstrap_tools
  os::ubuntu::apt_repo_hygiene
  os::ubuntu::ensure_cloudflared_repo
  os::ubuntu::ensure_tailscale_repo

  local core_packages=(
    binutils
    build-essential
    cpu-checker
    curl
    dnsutils
    dmsetup
    fd-find
    fonts-firacode
    fzf
    gawk
    git
    gnupg
    jq
    libpcsclite-dev
    libpq-dev
    neovim
    net-tools
    nmap
    openconnect
    openssh-client
    pkg-config
    python3-dev
    python3-full
    python3-pip
    python3-venv
    rclone
    restic
    rsync
    ripgrep
    ruby
    silversearcher-ag
    software-properties-common
    swig
    tcpdump
    tmux
    traceroute
    ufw
    unzip
    virtualenv
    wireguard-tools
    xclip
    yq
    zsh
  )

  sudo apt update
  apt::install_if_available "${core_packages[@]}"
  apt::install_if_available cloudflared tailscale
  desktop::install_clipboard_and_caffeine
  desktop::ensure_desktop_extensions_enabled
  desktop::apply_gnome_extension_preferences

  uv::ensure_installed
  tools::install_starship
  fonts::install_nerd_font
  terminal::configure_gnome_terminal_font
  nvm::install_node_default
  sudo apt install -y --no-install-recommends python3-neovim || true

  # Ubuntu names the package fd-find but many tools expect fd.
  if command -v fdfind >/dev/null 2>&1 && ! command -v fd >/dev/null 2>&1; then
    mkdir -p "${HOME}/.local/bin"
    ln -sf "$(command -v fdfind)" "${HOME}/.local/bin/fd"
  fi

  # Prefer Docker tooling over containerd/nerdctl.
  if ! command -v docker >/dev/null 2>&1; then
    sudo apt install -y --no-install-recommends docker.io docker-buildx docker-compose-v2
  else
    log::f "Docker already installed; skipping docker.io package install"
  fi
  docker::ensure_compose
  desktop::status_clipboard_and_caffeine

  if command -v snap >/dev/null 2>&1; then
    log::f "Installing snap packages"
    sudo snap install go --classic
    sudo snap install firefox
    sudo snap connect firefox:u2f-devices # Yubikey support
  fi
}

os::ubuntu::install_packages_dev() {
  log::f "Installing developer apt packages"

  local dev_packages=(
    ansible
    hugo
    picocom
    shellcheck
    shfmt
  )

  sudo apt update
  sudo apt install -y --no-install-recommends "${dev_packages[@]}"
  tools::install_opentofu
  go::ensure_installed
  tools::install_awscli
  tools::install_esp_tools
  tools::doctl

  # Keep fast-moving JS/Python tooling current from upstream registries.
  nvm::install_node_default
  mkdir -p "${HOME}/.local/bin"
  npm install -g --prefix "${HOME}/.local" \
    @google/gemini-cli \
    @openai/codex \
    @ansible/ansible-language-server \
    bash-language-server \
    dockerfile-language-server-nodejs \
    eslint_d \
    prettier \
    pyright \
    vscode-langservers-extracted \
    yaml-language-server
  uv::tool_install black
  uv::tool_install isort
  uv::tool_install ruff

  tools::verify_dev_cli
}

os::set_zoom_scaling_factor () {
  perl -i -pe 's/scaleFactor=2/scaleFactor=1/' ~/.config/zoomus.conf
}

go::install_developer_tools() {
  local modvendor_version golangci_lint_version
  modvendor_version="${MODVENDOR_VERSION:-v0.5.0}"
  golangci_lint_version="${GOLANGCI_LINT_VERSION:-v1.52.2}"

  go install "github.com/goware/modvendor@${modvendor_version}"
  go install "github.com/golangci/golangci-lint/cmd/golangci-lint@${golangci_lint_version}"
}

go::ensure_installed() {
  if command -v go >/dev/null 2>&1; then
    log::f "Go already installed: $(go version)"
    return 0
  fi

  if command -v snap >/dev/null 2>&1; then
    log::f "Installing go from snap"
    sudo snap install go --classic
  else
    log::f "Installing go from apt"
    sudo apt update
    sudo apt install -y --no-install-recommends golang-go
  fi
}



# Tools
#######

tools::install_terraform() {
  local VERSION=v1.4.6

  local out
  out="$(mktemp)"
  curl -sfLo "${out}" "https://releases.hashicorp.com/terraform/${VERSION:1}/terraform_${VERSION:1}_linux_${ARCH}.zip"
  sudo unzip "${out}" -d /usr/local/bin/
}

tools::install_awscli() {
  if command -v aws >/dev/null 2>&1; then
    log::f "AWS CLI already installed: $(aws --version 2>&1 | head -n1)"
    return 0
  fi

  if command -v snap >/dev/null 2>&1; then
    log::f "Installing AWS CLI from snap"
    sudo snap install aws-cli --classic
    return 0
  fi

  log::f "Installing AWS CLI via uv tool"
  uv::tool_install awscli
}

tools::install_ansible() {
  # sudo apt-add-repository -y ppa:ansible/ansible
  sudo apt update
  sudo apt install -y ansible
}

tools::install_vegeta() {
  local vegeta_version fallback_version fallback_module
  vegeta_version="${VEGETA_VERSION:-latest}"
  fallback_version="${VEGETA_FALLBACK_VERSION:-v12.11.1}"
  fallback_module="${VEGETA_FALLBACK_MODULE:-github.com/tsenart/vegeta/v12}"

  if go install "github.com/tsenart/vegeta@${vegeta_version}"; then
    return 0
  fi

  log::f "vegeta@${vegeta_version} install failed; retrying ${fallback_module}@${fallback_version} for older Go toolchains"
  if ! go install "${fallback_module}@${fallback_version}"; then
    log::f "Skipping vegeta install: compatible version could not be installed with current Go toolchain"
  fi
}

tools::wireshark() {
  # sudo add-apt-repository ppa:wireshark-dev/stable -y
  sudo apt update
  echo "wireshark-common wireshark-common/install-setuid boolean true" | sudo debconf-set-selections
  DEBIAN_FRONTEND=noninteractive sudo apt install -y wireshark
}

tools::nerdctl() {
  local VERSION=v1.3.1

  local out
  out="$(mktemp)"

  gh::download "containerd/nerdctl" "${VERSION}" "nerdctl-${VERSION:1}-linux-${ARCH}.tar.gz" "${out}"

  sudo tar Cxzvvf /usr/local/bin "${out}"
}

tools::doctl() {
  local VERSION latest_json
  if [ -n "${DOCTL_VERSION:-}" ]; then
    VERSION="${DOCTL_VERSION}"
  else
    latest_json="$(curl -fsSL https://api.github.com/repos/digitalocean/doctl/releases/latest)"
    VERSION="$(printf '%s\n' "${latest_json}" | sed -n 's/.*"tag_name":[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)"
    VERSION="${VERSION:-v1.94.0}"
  fi

  local out
  out="$(mktemp)"

  gh::download "digitalocean/doctl" "${VERSION}" "doctl-${VERSION:1}-linux-${ARCH}.tar.gz" "${out}"

  sudo tar Cxzvvf /usr/local/bin "${out}"
}

tools::install_opentofu() {
  if command -v tofu >/dev/null 2>&1; then
    log::f "OpenTofu already installed: $(tofu --version | head -n1)"
    return 0
  fi

  log::f "Installing OpenTofu from apt"
  os::ubuntu::ensure_opentofu_repo
  sudo apt update
  sudo apt install -y --no-install-recommends tofu
}

tools::install_esp_tools() {
  log::f "Installing ESP tools"
  uv::tool_install esptool

  local idf_root
  idf_root="${HOME}/.espressif/esp-idf"
  if [ ! -d "${idf_root}" ]; then
    mkdir -p "${HOME}/.espressif"
    git clone --depth 1 https://github.com/espressif/esp-idf.git "${idf_root}"
  fi

  if [ -f "${idf_root}/tools/idf.py" ]; then
    mkdir -p "${HOME}/.local/bin"
    ln -sf "${idf_root}/tools/idf.py" "${HOME}/.local/bin/idf.py"
    chmod +x "${idf_root}/tools/idf.py" || true
  fi
}

tools::verify_one() {
  local name cmd version_cmd version path
  name="$1"
  cmd="$2"
  version_cmd="$3"

  if command -v "${cmd}" >/dev/null 2>&1; then
    version="$(eval "${version_cmd}" 2>/dev/null | head -n1)"
    path="$(command -v "${cmd}")"
    log::f "${name}: ${version:-version unknown} (${path})"
  else
    log::e "${name} not found on PATH"
  fi
}

tools::verify_dev_cli() {
  log::f "Verifying key dev CLIs"
  tools::verify_one "Codex CLI" "codex" "codex --version"
  tools::verify_one "Gemini CLI" "gemini" "gemini --version"
  tools::verify_one "OpenTofu" "tofu" "tofu --version"
  tools::verify_one "doctl" "doctl" "doctl version"
  tools::verify_one "AWS CLI" "aws" "aws --version"
}

tools::dive() {
  local VERSION=v0.10.0

  local out
  out="$(mktemp)"

  gh::download "wagoodman/dive" "${VERSION}" "dive_${VERSION:1}_linux_${ARCH}.deb" "${out}"

  sudo dpkg -i "${out}"
}

tools::buildkit() {
  local VERSION=v0.11.6

  local out
  out="$(mktemp)"

  gh::download "moby/buildkit" "${VERSION}" "buildkit-${VERSION}.linux-${ARCH}.tar.gz" "${out}"

  sudo tar -C /usr/local/bin -xzvv --strip-components 1 -f "${out}"
}

tools::regctl() {
  local VERSION=v0.4.8

  local out
  out="$(mktemp)"

  gh::download "regclient/regclient" "${VERSION}" "regctl-linux-${ARCH}" "${out}"

  chmod +x "${out}"
  sudo mv "${out}" /usr/local/bin/regctl
}

tools::cf-terraforming() {
  local VERSION=v0.12.0

  local out
  out="$(mktemp)"

  gh::download "cloudflare/cf-terraforming" "${VERSION}" "cf-terraforming_${VERSION:1}_linux_${ARCH}.tar.gz" "${out}"

  sudo tar Cxzvvf /usr/local/bin "${out}"
}

tools::uv_basics() {
  uv::ensure_installed
  uv::tool_install oci-cli
  tools::install_yubikey_manager
  uv::tool_install isort
  uv::tool_install autopep8
}

tools::install_yubikey_manager() {
  if command -v ykman >/dev/null 2>&1; then
    log::f "yubikey-manager already installed: $(ykman --version 2>/dev/null | head -n1)"
    return 0
  fi

  if apt-cache show yubikey-manager >/dev/null 2>&1; then
    log::f "Installing yubikey-manager from apt"
    sudo apt install -y --no-install-recommends yubikey-manager pcscd || true
  fi

  if command -v ykman >/dev/null 2>&1; then
    return 0
  fi

  log::f "Installing yubikey-manager via uv tool fallback"
  if ! uv tool install --force --upgrade yubikey-manager; then
    log::f "Skipping yubikey-manager: uv install failed (likely missing optional smartcard build/runtime deps)"
  fi
}

tools::full_install() {
  go::install_developer_tools
  tools::install_ansible
  tools::install_vegeta
  tools::wireshark
  # tools::dive # FIXME(apryde): dive only supports docker and that's verboten
  tools::buildkit
  tools::regctl
  tools::doctl
  tools::cf-terraforming
  tools::uv_basics
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  case "${1:-}" in
    full-install)
      tools::full_install
      ;;
    "")
      echo "No action selected. Use: $0 full-install"
      ;;
    *)
      echo "Unknown action: $1"
      echo "Usage: $0 full-install"
      exit 1
      ;;
  esac
fi

# TODO:
# - SSLScan (https://github.com/ioerror/sslscan)
